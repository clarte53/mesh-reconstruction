#include "ProceduralRenderingHelpers.cginc"

// One kernel to Generate XYZTexture from kinect data
// One kernel to Generate ColorTexture from kinect data
#pragma kernel VertexGenerator
#pragma kernel ColorGenerator
#pragma enable_d3d11_debug_symbols

int depthWidth;
int depthHeight;
int colorWidth;
int colorHeight;
StructuredBuffer<int> Input_positionData;
//StructuredBuffer<float3> Input_positionData;
StructuredBuffer<uint> Input_colorData;


RWTexture2D<float4> Output_vertexTexture;
RWTexture2D<float4> Output_colorTexture;



[numthreads(1, 1, 1)]
void VertexGenerator(uint3 id : SV_DispatchThreadID)
{
	//int index = depthWidth * id.y + id.x;
	int index = depthWidth * (depthHeight - id.y) + (depthWidth - id.x);

	half output_x;
	half output_y;
	half output_z;

	int group_base = floor(index / 2);
	if (fmod(index, 2) == 0) {
		int firstInt = Input_positionData[group_base * 3];
		int secondInt = Input_positionData[group_base * 3 + 1];
		output_x = (firstInt >> 0) & 0xffff;
		output_y = (firstInt >> 16) & 0xffff;
		output_z = (secondInt >> 0) & 0xffff;
	}
	else {
		int firstInt = Input_positionData[group_base * 3 + 1];
		int secondInt = Input_positionData[group_base * 3 + 2];
		output_x = (firstInt >> 16) & 0xffff;
		output_y = (secondInt >> 0) & 0xffff;
		output_z = (secondInt >> 16) & 0xffff;
	}
	
	output_x = output_x *0.001;
	output_y = output_y *0.001;
	output_z = output_z *0.001;

	// Get results
	/*float output_x = -Input_positionData[index].x;
	float output_y = Input_positionData[index].y;
	float output_z = Input_positionData[index].z;*/

	/*float output_x = -Input_positionData[index] * 0.001;
	float output_y = Input_positionData[index + (depthHeight * depthWidth)] * 0.001;
	float output_z = Input_positionData[[index + (depthHeight * depthWidth * 2)] * 0.001;*/

	/*float output_x = -Input_positionData[index * 3] * 0.001;
	float output_y = -Input_positionData[index * 3 + 1] * 0.001;
	float output_z = -Input_positionData[index * 3 + 2] * 0.001;*/

	

	/*float output_x = 0;
	if (Input_positionData[index * 3] * 0.001 > 0) {
		output_x = id.x / depthWidth;
	}
	float output_y = 0;
	if (-Input_positionData[index * 3 + 1] * 0.001 > 0) {
		output_y = id.y / depthHeight;
	}
	float output_z = 0; 
	if (Input_positionData[index * 3 + 2] * 0.001 > 0) {
		output_z = Input_positionData[index * 3 + 2];
	}*/

	float2 uv = float2((depthWidth - id.x) / (float)depthWidth, (depthHeight - id.y) / (float)depthHeight);
	uv.y = 1.0 - uv.y;
	uv.x = 1.0 - uv.x;

	float output_uv = EncodeUV(uv);

	// Fill rendertexture
	Output_vertexTexture[id.xy] = float4((float)output_x, (float)output_y, (float)output_z, output_uv);
	//Output_vertexTexture[id.xy] = float4(output_x, 0, 0, output_uv);
}

[numthreads(1, 1, 1)]
void ColorGenerator(uint3 id : SV_DispatchThreadID)
{
	//int index = colorWidth * id.y + id.x;
	int index = colorWidth * (colorHeight - id.y) + (colorWidth - id.x);

	// Get results from color data buffer
	uint uintColor = Input_colorData[index];

	// Split uint to get the 4 bytes of color
	uint output_byte_b = (uintColor >> 0) & 0xff;
	uint output_byte_g = (uintColor >> 8) & 0xff;
	uint output_byte_r = (uintColor >> 16) & 0xff;
	uint output_byte_a = (uintColor >> 24) & 0xff;

	// Fill rendertexture
	Output_colorTexture[id.xy] = float4(float(output_byte_r) / 255.0, float(output_byte_g) / 255.0, float(output_byte_b) / 255.0, float(output_byte_a) / 255.0);
}
